# %% [markdown]
# Fractal curves with segmentedMap

When I wrote [in praise of the map function](./in-praise-of-the-map-function.html) I proposed a modest extension of the p5 map function called segmentedMap. Now that was supposed to be the end of it, but while I was walking the dog it suddenly occurred to me that we can call it recursively in order to draw and do creative things with fractal curves such as the Koch Snowflake and the Hilbert Curve.

## Vectorizing the map function

Actually I was wrong - a variant of the (scalar) map function gives you an interesting and creative way of getting from point A to point B, but to draw these curves we sometimes need to go sideways.. which means we need to know which way sideways is... something we need both the x and y coordinate in order to determine.

So lets write a version of the map function that uses vectors, rather than a single (scalar) value for its target range. This is probably a good thing anyway, as intermediate to advanced programmers usually find it more convenient to think and code with vectors.

# %%--- [javascript]
# properties:
#   top_hidden: true
#   run_on_load: true
# ---%%
var p5WithCleanup = (sketch, text) => {
    if (!window.sketches) {
        window.sketches = {};
    }

    if (window.sketches[text]) {
        window.sketches[text].remove();
    }

    const matchedElements = Array.from(
        document.querySelectorAll('.cell-bottom'),
    );

    const matchedElement = matchedElements.find(
        (elm) => elm.parentElement.textContent.split(text).length > 1,
    );

    if (!matchedElement) {
        throw new Error(`p5WithCleanup: text not found '${text}'`);
    }

    const p5Instance = new p5(sketch, matchedElement);
    window.sketches[text] = p5Instance;
    return p5Instance;
};

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
await import('../../p5/lib/p5.js');

var createVectorMapFn = (p) => {
    var vectorMap = (n, start1, stop1, start2, stop2) => {
        return p.createVector(
            p.map(n, start1, stop1, start2.x, stop2.x),
            p.map(n, start1, stop1, start2.y, stop2.y),
        );
    };

    return vectorMap;
};

# %% [markdown]
Nothing exciting there, we're just calling the map function twice, first to map the x-coordinate then to map the y-coordinate, and creating a new vector from the result.

## Example sketch: Moving a Circle

This was the most simple animation I could think of with the (scalar) map function:

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
var animatedCircle = (p) => {
    var animationLength = 200;

    p.setup = () => {
        p.createCanvas(300, 300);
    };

    p.draw = () => {
        p.background(200);

        var xStart = 50;
        var yStart = 250;
        var xStop = 250;
        var yStop = 50;
        var frame = p.frameCount % animationLength;
        var x = p.map(frame, 1, animationLength, xStart, xStop);
        var y = p.map(frame, 1, animationLength, yStart, yStop);
        p.ellipse(x, y, 20);
    };
};

p5WithCleanup(animatedCircle, 'animatedCircle');

# %% [markdown]
Here's what it looks like if we use vectorMap instead:

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
var animatedCircleVectorised = (p) => {
    var animationLength = 200;
    var vectorMap = createVectorMapFn(p);

    p.setup = () => {
        p.createCanvas(300, 300);
    };

    p.draw = () => {
        p.background(200);

        var start = p.createVector(50, 250);
        var stop = p.createVector(250, 50);
        var frame = p.frameCount % animationLength;

        var vec = vectorMap(frame, 1, animationLength, start, stop);

        p.ellipse(vec.x, vec.y, 20);
    };
};

p5WithCleanup(animatedCircleVectorised, 'animatedCircleVectorised');

# %% [markdown]
Exactly the same boring animation, but the code is slightly more elegant, maybe?

## A single iteration of the Koch Snowflake

The algorithm for the [Koch Snowflake](https://en.wikipedia.org/wiki/Koch_snowflake) is to recursively mutate each line segment by replacing the middle third of it with the other two sides of an equilateral triangle. I'd probably better draw (a non-recursive example) of that:

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
var heightOfEquilateralTriangle = (sideLength) =>
    (Math.sqrt(3) * sideLength) / 2;

var singleKochSnowflakeStep = (p) => {
    var animationLength = 200;
    var vectorMap = createVectorMapFn(p);

    p.setup = () => {
        p.createCanvas(300, 300);
    };

    p.draw = () => {
        p.background(200);

        var frame = p.frameCount % animationLength;
        var drawLineSegment = frame < animationLength / 2;

        var a = p.createVector(150, 250);
        var e = p.createVector(150, 50);

        var b = vectorMap(1, 0, 3, a, e);
        var d = vectorMap(2, 0, 3, a, e);

        var sideLength = d.copy().sub(b).mag();

        var c = p.createVector(
            150 - heightOfEquilateralTriangle(sideLength),
            p.map(1, 0, 2, a.y, e.y),
        );

        p.strokeWeight(2);
        p.noFill();

        if (drawLineSegment) {
            // Draw line segment
            p.beginShape();
            [a, e].forEach((point) => p.vertex(point.x, point.y));
            p.endShape();
        } else {
            // Replace middle third with the other two sides of an equilateral triangle
            p.beginShape();
            [a, b, c, d, e].forEach((point) => p.vertex(point.x, point.y));
            p.endShape();
        }
    };
};
p5WithCleanup(singleKochSnowflakeStep, 'singleKochSnowflakeStep');

# %% [markdown]
How did I know the height of an equilateral triangle was `Math.sqrt(3) * sideLength / 2`? I looked it up online, of course ;-)

You can also split the equilateral triangle into two right-angled triangles and use Pythagoras' theorem...

```
a^2 = b^2 + c^2
```

...by substituting in the values related to this problem...

```
sideLength^2 = (sideLength / 2)^2 + heightOfEquilateralTriangle
```

...then re-arranging until you have `heightOfEquilateralTriangle = Math.sqrt(3) * sideLength / 2`

## segmentedMap

We're nearly ready to express the Koch Snowflake as a map, but first we need to bring the segmentedMap function in:

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
var map = (n, start1, stop1, start2, stop2) => {
    return ((n - start1) / (stop1 - start1)) * (stop2 - start2) + start2;
};

var segmentedMap = (value, range1, range2, maps) => {
    if (range1.length !== range2.length) {
        throw new Error('segmentedMap range arrays not equal');
    }

    const n = range1.findIndex((t) => t > value);
    switch (n) {
        case 0:
            return range2[0];
        case -1:
            return range2[range2.length - 1];
        default:
            var currentMap = maps && maps[n - 1] ? maps[n - 1] : map;
            return currentMap(
                value,
                range1[n - 1],
                range1[n],
                range2[n - 1],
                range2[n],
            );
    }
};

# %% [markdown]
This is the same code I used in [in praise of the map function](./in-praise-of-the-map-function.html). I haven't had to adjust it at all to allow for the fact we're now working with vectors, because the elements of range2 just get passed to another map without being used in any other way, and the returned value just gets passed through too.

# kochSnowflakeMap

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
var createKochSnowflakemapFn = (p) => {
    var vectorMap = createVectorMapFn(p);

    var kochSnowflakeMap = (depth) => (n, start1, stop1, start2, stop2) => {
        var ratio = map(n, start1, stop1, 0, 1);

        var b = vectorMap(2, 0, 6, start2, stop2);
        var c = vectorMap(3, 0, 6, start2, stop2);
        var d = vectorMap(4, 0, 6, start2, stop2);

        var bdNormal = d.copy().sub(b).rotate(p.HALF_PI);
        bdNormal.setMag(heightOfEquilateralTriangle(bdNormal.mag()));

        c.add(bdNormal);

        var nextMap = depth <= 1 ? vectorMap : kochSnowflakeMap(depth - 1);

        return segmentedMap(
            ratio,
            [0, 0.25, 0.5, 0.75, 1],
            [start2, b, c, d, stop2],
            [nextMap, nextMap, nextMap, nextMap],
        );
    };

    return kochSnowflakeMap;
};

# %% [markdown]
# Quick sketch to look at that with

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
var quickSketch = (p) => {
    var kochSnowflakeMap = createKochSnowflakemapFn(p);
    var vectorMap = createVectorMapFn(p);

    p.setup = () => {
        p.createCanvas(640, 480);
        p.background(244);
    };

    var kochSnowflakeTop = (value, start1, stop1, depth) => {
        var range1 = [];
        var range2 = [];

        var value03 = p.map(value, start1, stop1, 0, 3);

        var nextMap = depth <= 1 ? vectorMap : kochSnowflakeMap(depth - 1);

        var radius = 220;
        var centre = p.createVector(p.width / 2, p.height / 2);

        for (var n = 0; n < 4; ++n) {
            range1.push(n);

            var angle = p.map(n, 0, 3, 0, p.TWO_PI) + p.HALF_PI;

            var vec = p.createVector(
                radius * Math.cos(angle),
                radius * Math.sin(angle),
            );

            range2.push(vec.add(centre));
        }

        return segmentedMap(value03, range1, range2.reverse(), [
            nextMap,
            nextMap,
            nextMap,
        ]);
    };

    p.draw = () => {
        p.strokeWeight(2);
        p.noFill();

        p.beginShape();

        var points = 10000;
        for (var n = 0; n < points; ++n) {
            var point = kochSnowflakeTop(n, 0, points, 3);

            p.vertex(point.x, point.y);
        }

        p.endShape();

        p.noLoop();
    };
};
p5WithCleanup(quickSketch, 'quickSketch');

# %% [markdown]
# Now start playing with the Hilbert Curve

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
var hilbertPlay = (p) => {
    var vectorMap = createVectorMapFn(p);

    p.setup = () => {
        p.createCanvas(640, 480);
        p.background(244);
    };

    var hilbertCurvePoints = (centre, radius, angle) => {
        return [1.5, 2.5, 3.5, 4.5].map((corner) => {
            var theta = (p.HALF_PI * corner) + angle;
            var vec = p.createVector(
                radius * Math.cos(theta),
                radius * Math.sin(theta),
            );
            return vec.add(centre);
        });
    };

    var logPoint = (vec) => {
        p.ellipse(vec.x, vec.y, 10);
        console.log(`x: ${vec.x}, y: ${vec.y}`)
    };

    p.draw = () => {
        p.strokeWeight(2);
        p.noFill();

        var centre = p.createVector(p.width / 2, p.height / 2);
        var curvePoints = hilbertCurvePoints(centre, 100, p.PI);

        var points = 1000;

        var ranges = Array.from({ length: curvePoints.length }).map(
            (v, index) => p.map(index, 0, curvePoints.length, 0, points),
        );

        var maps = Array.from({ length: curvePoints.length }).fill(vectorMap);

        p.beginShape();

        for (var n = 0; n < points; ++n) {
            var point = segmentedMap(n, ranges, curvePoints, maps);

            p.vertex(point.x, point.y);
        }

        p.endShape();

        p.noLoop();
    };
};
p5WithCleanup(hilbertPlay, 'hilbertPlay');
